-------------------------------------------------------------------------------------------
스프링 FrameWork의 특징
-------------------------------------------------------------------------------------------
- IOC (Inversion Of Control) 제어의 역전
	개발자가 직접 구현했던 것들을 프레임워크로 가져갔다.
	그만큼 개발자가 할 일이 없다. 
	인수인계가 용이하다.

- DI (Dependency Injection) 의존주입
	멤버 컨트롤러를 하나 만들었는데 일련의 DB 기로에서의 업무로직을 처리하기 위해서 멤버 서비스라는 객체가 필요했다. 
	이제는 멤버서비스 = new 멤버서비스 이렇게 하지 않고, 
	
	멤버서비스를 필드로서 선언만 할 것이다. 
	이걸 프레임워크쪽에서 자동으로 넣어준다. 
	이것을 DI라고 한다. 
	
	멤버컨트롤러는 멤버 서비스 없이는 아무 일도 못한다. 
	업무로직을 멤버서비스에 요청하지 못하기 때문에. 
	멤버서비스는 멤버컨트롤러에 대해 의존이다.
	
	그 의존을 주입해주는 것을 프레임워크쪽에서 한다.
	제어가 역전된거다. 
	
	멤버서비스 멤버서비스타입의 m이란 변수에 new 멤버서비스해서 객체를 만들어 넣었는데 이제는 그럴 필요가 없다.

	IOC와 DI는 따라 다니는 개념이다. 
	같은 맥락에서 이해하면 좋다.


- AOP (Aspect Oriented Programming) 관점지향프로그래밍
	공통된 업무들을 별도로 빼서 처리하는 것이다. 
	서버쪽에 기록을 남기는 작업을 별도로 관리한다.
	
	* cf) 생활코딩 설명
	AOP
	관점지향형 프로그램으로 사용자들이 트랜젝션 처리/로깅/예외 처리들의 로직을 공통으로 처리할 수 있는 기능을 지원함. 
	해당 기능을 잘 사용하면 비지니스로직와 기타 공통모듈이 섞이는 것을 방지하여 비지니스 로직에 집중할 수 있도록 합니다.

* IOC, DI, AOP 는 필수로 알고 있어야 한다.

- POJO (Plain Old Java Object) 평범하고 늙은 자바 객체 <-> ejb 
	ejb는 예전 기업용 프레임워크이다. (현재에도 씀) 
	ejb에서는 객체들은 상속을 받고 구현을 하고... 기능이 많은 대신 객체 하나 쓰기를 까다롭다.
	
	POJO는 ejb와 달리 우리가 편하고 쉽게 알 수 있는 자바 객체이다.
	
	* cf) 생활코딩 설명
	POJO (Plain Object Java  Object)
	기본적으로 사용자가 만들어낸 객체를 의미함. 
	스프링은 사용자가 만들 객체들에 대해서도 라이프사이클 관리를 위임해서 수행하며, 이들의 조합으로 어플리케이션을 만들 수 있음.
	
- PSA (Portable Service Abstraction) 추상화된 제어
	예를 들면 JDK에도 로깅을 지원하는 프레임워크가 있다. 
	당신이 뭘 사용하던지간에 log4j를 사용하든 다른 로깅프레임워크를 사용하든 
	이것을 상위레벨에서 제어할 수 있다는 것이다.
	
	* cf) 생활코딩 설명
	PSA(Portable Service Abstraction)
	스프링은 다른 여러 모듈을 사용함에 있어서 별도의 추상화 레이어를 제공합니다. 
	예를 들어 JPA를 사용할 때에서 Spring JPA를 사용하여 추상화 하므로 
	실제 구현에 있어서 Hibernate를 사용하든 EclipseLink를 사용하든 사용자는 이 모듈의 의존 없이 프로그램에 집중할 수 있습니다.

-------------------------------------------------------------------------------------------
pom.xml (프로젝트 하위)
-------------------------------------------------------------------------------------------
Maven Project는 pom.xml이 가장 핵심적인 파일이다. 모든 것이 시작된다.
모든 의존을 관리하기 때문에 중요하다.
수정돼서 저장될때마다 바로 Web에 접속에서 다운로드 받는다.

<!-- 
	우리가 만든 3레벨의 패키지가 나누어져 기록되어 있다.
	artifactId가 ContextPath로 사용되고 있다.
-->

<groupId>com.kh</groupId>
<artifactId>spring</artifactId>

<!-- properties : 버전정보를 태그명으로 저장해서 다른 소스에서 참조한다. -->
<properties>
	<java-version>1.8</java-version>
	<!-- 무턱대고 버전을 올리면 다른 의존이랑 깨지기 때문에 테스트를 마친 5.0.6 버전을 사용하겠다. -->
	<org.springframework-version>5.0.6.RELEASE</org.springframework-version>
	<org.aspectj-version>1.6.10</org.aspectj-version>
	<org.slf4j-version>1.6.6</org.slf4j-version>
</properties>



<dependencies>
	<dependency>
		<groupId>org.springframework</groupId>
		<artifactId>spring-context</artifactId>
		<version>${org.springframework-version}</version>
		<exclusions>
			<!-- Exclude Commons Logging in favor of SLF4j -->
			<exclusion>
				<groupId>commons-logging</groupId>
				<artifactId>commons-logging</artifactId>
			 </exclusion>
		</exclusions>
	</dependency>
</dependencies>

${org.springframework-version} : properties에 적어준 <org.springframework-version> 를 태그명으로 저장한 것.
dev/maven/repository 에 들어가보자
dependencies 태그 밑의 경로를 따라가보면 다운로드 받은 것이 들어있다.
org.springframework/spring-context/${org.springframework-version}


Ctrl + Shift + L 누르면 Quick Text Search 가 열린다.
workspace 전체를 대상으로 검색한다.
검색하고자 하는 키워드를 입력해서 필요한 것을 찾으면 된다.


ojdbc6는 중앙저장소(공식저장소)에 있는 것을 쓰지 못한다.
그래서 별도로 사설저장소를 등록해줘야한다.
<!-- #1.1 사설저장소 등록 -->
<repositories>
	<repository>
		<id>datanucleus-repo</id>
		<url>http://www.datanucleus.org/downloads/maven2/</url>
	</repository>
</repositories>

properties 태그가 끝나는 곳에 작성한다.
xml에 태그들이 위치하는 순서가 있기 때문에 잘 지켜줘야 한다.

사설저장소도 막히면 lib밑에 필요한 jar파일을 직접 넣어준다.

	
-------------------------------------------------------------------------------------------
web.xml (WEB-INF 하위)
-------------------------------------------------------------------------------------------
<!-- 스프링은 우리가 만든 클래스들을 빈으로 만들어 프로그램을 관리한다. -->
<!-- 빈은 프레임워크에서 관리하는 자바객체이다. 만들어놓고 등록만해주면 알아서 해준다. -->
<!-- 빈을 만들어 관리하는 스코프가 2개 있다.
1. root-Context : 
				프로그램당 1개. 
				프로그램에서 전체적으로 쓸 수 있는 것을 루트로 만든다. 
				루트는 데이터베이스 관련 빈들을 root-Context에 만들고, 
				서블릿 안에서 해결해야 하는 것들은 servlet-context안에서 비교분석하겠다는 뜻이다. 
2. servlet-context : 프로그램당 여러 개 가능하다. -->

<!-- root-context 기능  >> servlet-context 기능 -->


DB관련된 것들은 root에 만들어서 관리할 것이다.
서블릿이 여러개가 된다고 해도 다 처리할 수 있도록. (#6 참고)

-------------------------------------------------------------------------------------------
servlet-context.xml (WEB-INF/spring/appServlet 하위)
-------------------------------------------------------------------------------------------
<annotation-driven />
	mvc 관련한 어노테이션을 처리해준다.

<resources mapping="/resources/**" location="/resources/" />
	사용자 요청중에 wepapp(루트) 밑에 resources 밑에 뭐라고 요청하던지 resources 밑에 가서 요청을 처리한다. 
	<!-- 이미지, css등 자원 경로를 안내함. (매핑시켜줌) -->
	
	resources란?
	이미지, js 및 css 파일과 같은 정적 리소스를 캐시 헤더로 서비스하기 위한 핸들러 구성 
	웹 브라우저에서 효율적인 로딩을 위해 최적화. 리소스가 모든 경로에서 서비스되도록 허용 
	스프링의 리소스 취급을 통해 연결 가능.
	
	속성
	- mapping
	이 처리기의 리소스를 제공하는 데 사용할 현재 Servlet 컨텍스트 내의 URL 매핑 패턴, 
	예: "/resources/**"
	
	-location
	스프링 리소스 패턴으로 지정된 정적 컨텐츠를 처리할 리소스 위치. 
	각각 위치는 유효한 디렉토리를 가리켜야 한다. 
	여러 위치를 쉼표로 구분된 목록으로 지정할 수 있으며, 
	지정된 순서대로 지정된 리소스에 대해 위치를 점검하십시오. 
	예를 들어 "/, classpath:/META-INF/public-web-resources/"는 웹 앱에서 모두 리소스를 서비스할 수 있도록 한다. 
	/META-INF/public-web-resources/ 디렉토리를 포함하는 classpath의 모든 JAR에서 
	웹 애플리케이션 루트의 리소스 우선 순위 URL 기반 리소스(예: 파일, HTTP URL 등)의 경우 
	속성이 URL과 연관된 문자 집합을 나타내는 특수 접두사를 지원하므로 
	여기에 추가된 것은 "[Charset=Windows-31J]http://example.org/path"과 같이 올바르게 인코딩될 수 있다.
	
<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
	<beans:property name="prefix" value="/WEB-INF/views/" />
	<beans:property name="suffix" value=".jsp" />
</beans:bean>
	InternalResourceViewResolver : View단을 처리한다.
	
	class는 클래스가 어디 위치해있는지만 알려준다. (매핑)
	<beans:property name="prefix" value="/WEB-INF/views/" />
	<beans:property name="suffix" value=".jsp" />
	이 설정으로 인해 Controller에서 return 파일명만 해줘도 된다.
	
<context:component-scan base-package="com.kh.spring" />
	스프링컨테이너에 의해 자동 bean 등록
	base-package에 적힌 동일패키지나 하위패키지에서
	@Component 어노테이션이 붙은 클래스를 자동으로 검색해서 bean으로 등록한다.
	
	별도의 이름 지정이 없다면 빈의 이름은 소문자로 시작하는 클래스명이다.
	빈으로 등록되지 않은 클래스는 스프링컨테이너에 의해 사용불가.
	Framework에서 중요하다.


-------------------------------------------------------------------------------------------
Oracle SQL Developer 설정
-------------------------------------------------------------------------------------------
1. 관리자 system에서 사용자 spring생성
	create user spring identified by spring
	default tablespace users;
	
	grant connect, resource to spring;

2. 접속 생성
	접속 이름, 사용자 이름, 비밀번호 : spring 저장

3. spring.sql 작성
	--dev 테이블생성
	create table dev(
	    dev_no number primary key,
	    dev_name varchar2(50) not null,
	    dev_age number,
	    dev_email varchar2(100) not null,
	    dev_gender char(1) check(dev_gender in ('M', 'F')),
	    dev_lang varchar2(100) not null
	);

--시퀀스 생성
	create sequence seq_dev_no;
	
	
-------------------------------------------------------------------------------------------
DemoController
-------------------------------------------------------------------------------------------
@Controller클래스 메소드가 가질 수 있는 파라미터
	- HttpServletRequest
	- HttpServletResponse
	- HttpSession
	
	- InputStream / Reader : 요청에 대한 입력
	- OutputStream / Writer : 응답에 대한 출력
	
	하위 어노테이션을 가진 매개변수를 사용할 수 있다.
	- @PathVariable
	- @RequestParam
	- @RequestHeader
	- @CookieValue
	- @RequestBody
	
	- Map, Model, ModelMap : 뷰에 전달할 모델 데이터를 가진 객체 (속성에 저장할 필요없이 이 객체에 넣으면 된다)
	- Command객체 - vo객체
	- Error, BindingResult : 유효성 검사 관련 객체
	- SessionStatus : 세션관리객체
	- java.util.Locale : 서버지역정보
	


@Controller
public class DemoController {

	// DI (의존주입)
	// 필드로 생성
	@Autowired
	DemoService demoService;
	
	@RequestMapping("/demo/demo.do")
	public String demo() {
		System.out.println("demo메소드가 요청되었습니다.");
		
		// 리턴할 페이지를 적어준다.
		return "demo/demo"; // /WEB-INF/views/demo/demo.jsp
	}

	* DispatcherServlet 하나로 
	* .do로 끝나는 모든 요청을 받아서 처리하고 실제 요청은 메소드로 컨트롤러에 위임하게 된다.
	* 예를 들면 @ReqeustMapping 어노테이션을 사용해서 (사용자의 요청. url. 요청메소드(get|post)) 알맞게 해당메소드로 연결시켜줄 수 있다.
	
	* return은 리턴할 페이지를 적어준다.
	* 경로를 포함해서 적어줄 수 있다.
	* return "demo/demo"; // /WEB-INF/views/demo/demo.jsp 여기로 view단을 선정해서 간다.
	 



	
	 * @RequestParam(value="devName")에 전송된 값을 String devName에 담아라)
	 * RequestParam으로 지정한 것은 반드시 value가 있어야 한다.
	 * required 속성의 기본값은 true이다.
	 * false로 해야 value가 없어도 에러가 발생하지 않는다.
	 * 
	 * defaultValue : 값이 없다면 이것으로 대체
	 * Spring에서는 HttpServletRequest 대신 Model을 많이 사용한다.
	 * Model에 담아도 HttpServletRequest와 마찬가지로 EL로 접근할 수 있다.
	 
@RequestMapping("/demo/demo2.do")
public String demo2(Model model, 
					@RequestParam(value="devName", required=false) String devName,
					@RequestParam(value="devAge", defaultValue="30") int devAge,
					@RequestParam(value="devEmail") String devEmail,
					@RequestParam(value="devGender") String devGender,
					@RequestParam(value="devLang") String[] devLang) {
	
	Dev dev = new Dev(0, devName, devAge, devEmail, devGender, devLang);
	
	model.addAttribute("dev", dev);
	
	System.out.println("demo2메소드가 요청되었습니다.");
	System.out.println("dev@demo2()@DemoController = " + dev);
	
	// 리턴할 페이지를 적어준다.
	return "demo/demoResult"; // /WEB-INF/views/demo/demoResult.jsp
	
}



	 * value와 method 둘 다 배열이다.
	 * method= RequestMethod.POST  POST만 받는다. URL로 접근하면 에러
	 * 
	 * Dev dev 커맨드 객체
	 * 커맨드 패턴(Command pattern)이란 
	 * 요청을 객체의 형태로 캡슐화하여 사용자가 보낸 요청을 나중에 이용할 수 있도록 
	 * 매서드 이름, 매개변수 등 요청에 필요한 정보를 저장 또는 로깅, 취소할 수 있게 하는 패턴이다.
	@RequestMapping(value= "/demo/insertDev.do", method= RequestMethod.POST)
	public String insertDev(Dev dev) {
		// 업무로직
		
		int result = demoService.insertDev(dev);
		
		System.out.println("insertDev메소드가 요청되었습니다.");
		System.out.println(result > 0? "등록성공":"등록실패");
		
		// 리다이렉트 하는 법 : redirect: 하고 다음 요청 주소를 적으면 된다. /는 인덱스
		return "redirect:/demo/demoList.do";
	}


-------------------------------------------------------------------------------------------
Dev (vo)
-------------------------------------------------------------------------------------------
DB할때 char타입은 되도록 안 쓰는게 좋다.
나중에 형변환할때 다 스트링으로 들어가기 때문이다.
	 

	 